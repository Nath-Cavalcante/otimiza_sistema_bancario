from typing import Optional, List, Dict, Any
from datetime import datetime

from fastapi import FastAPI, APIRouter, Body, status, Depends, Query, HTTPException
from fastapi_pagination import add_pagination, Page, paginate, Params

# Importações Assíncronas do SQLAlchemy
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey, select, func
from sqlalchemy.orm import relationship, sessionmaker, declarative_base
from sqlalchemy.exc import IntegrityError
from sqlalchemy.future import select as sa_select # Renomeado para evitar conflito

from pydantic import BaseModel, Field, PositiveFloat, PositiveInt

# ====================================================================
# 1. CONFIGURAÇÃO DO BANCO DE DADOS ASSÍNCRONO
# ====================================================================

# Usamos 'sqlite+aiosqlite' para o driver assíncrono
SQLALCHEMY_DATABASE_URL = "sqlite+aiosqlite:///./app_crossfit.db"

# Cria a engine assíncrona do banco de dados
async_engine = create_async_engine(
    SQLALCHEMY_DATABASE_URL, 
    echo=False, 
    connect_args={"check_same_thread": False}
)

# Base Declarativa para os modelos SQLAlchemy
Base = declarative_base()

# Cria o SessionLocal assíncrono
AsyncSessionLocal = async_sessionmaker(
    async_engine, 
    expire_on_commit=False, 
    class_=AsyncSession
)

# Funções utilitárias para criar as tabelas
async def init_db():
    async with async_engine.begin() as conn:
        # await conn.run_sync(Base.metadata.drop_all) # Opcional: para limpar o banco
        await conn.run_sync(Base.metadata.create_all)

# Dependency para obter a sessão assíncrona do banco de dados
async def get_db_async() -> AsyncSession:
    async with AsyncSessionLocal() as session:
        yield session

# ====================================================================
# 2. MODELOS (SQLAlchemy ORM) - Sem Alterações Estruturais (Apenas uso do Base)
# ====================================================================

class CategoriaModel(Base):
    """Modelo SQLAlchemy para a tabela Categoria."""
    __tablename__ = 'categorias'
    pk_id = Column(Integer, primary_key=True, index=True)
    nome = Column(String(50), unique=True, nullable=False)
    atletas = relationship("AtletaModel", back_populates="categoria")

class CentroTreinamentoModel(Base):
    """Modelo SQLAlchemy para a tabela Centro de Treinamento (CT)."""
    __tablename__ = 'centros_treinamento'
    pk_id = Column(Integer, primary_key=True, index=True)
    nome = Column(String(50), unique=True, nullable=False)
    endereco = Column(String(100), nullable=False)
    proprietario = Column(String(50), nullable=False)
    atletas = relationship("AtletaModel", back_populates="centro_treinamento")

class AtletaModel(Base):
    """Modelo SQLAlchemy para a tabela Atleta."""
    __tablename__ = 'atletas'
    pk_id = Column(Integer, primary_key=True, index=True)
    nome = Column(String(50), nullable=False)
    cpf = Column(String(11), unique=True, nullable=False)
    idade = Column(Integer, nullable=False)
    peso = Column(Float, nullable=False)
    altura = Column(Float, nullable=False)
    sexo = Column(String(1), nullable=False)
    data_criacao = Column(DateTime, default=datetime.utcnow)
    categoria_id = Column(Integer, ForeignKey('categorias.pk_id'))
    centro_treinamento_id = Column(Integer, ForeignKey('centros_treinamento.pk_id'))
    categoria = relationship("CategoriaModel", back_populates="atletas")
    centro_treinamento = relationship("CentroTreinamentoModel", back_populates="atletas")

# ====================================================================
# 3. SCHEMAS (Pydantic) - Sem Alterações
# ====================================================================

# Schemas de Entrada (INPUT)
class CategoriaIn(BaseModel):
    nome: str = Field(..., description='Nome da categoria', example='Iniciante', max_length=50)

class CentroTreinamentoIn(BaseModel):
    nome: str = Field(..., description='Nome do CT', example='CT Thunder', max_length=50)
    endereco: str = Field(..., description='Endereço do CT', example='Rua X, 100', max_length=100)
    proprietario: str = Field(..., description='Nome do proprietário', example='Marcos Vinicius', max_length=50)

class AtletaIn(BaseModel):
    nome: str = Field(..., description='Nome do atleta', example='Joao', max_length=50)
    cpf: str = Field(..., description='CPF do atleta', example='12345678900', max_length=11)
    idade: PositiveInt = Field(..., description='Idade do atleta', example=25)
    peso: PositiveFloat = Field(..., description='Peso do atleta', example=75.5)
    altura: PositiveFloat = Field(..., description='Altura do atleta', example=1.70)
    sexo: str = Field(..., description='Sexo do atleta', example='M', max_length=1)
    
    categoria_nome: str = Field(..., description='Nome da categoria', example='Iniciante', max_length=50)
    centro_treinamento_nome: str = Field(..., description='Nome do CT', example='CT Thunder', max_length=50)

# Schemas de Saída (OUTPUT) - Base
class CategoriaOut(CategoriaIn):
    pk_id: int
    class Config:
        orm_mode = True

class CentroTreinamentoOut(CentroTreinamentoIn):
    pk_id: int
    class Config:
        orm_mode = True

# Schemas de Saída (OUTPUT) - Atleta Completo
class AtletaOut(AtletaIn):
    pk_id: int
    data_criacao: datetime
    class Config:
        orm_mode = True

# Schema de Saída Customizado (OUTPUT)
class AtletaCustomOut(BaseModel):
    nome: str = Field(..., description='Nome do atleta', example='Joao')
    centro_treinamento: str = Field(..., description='Nome do CT', example='CT Thunder')
    categoria: str = Field(..., description='Nome da categoria', example='Iniciante')

# ====================================================================
# 4. ROTAS (ENDPOINTS) - Uso de `await` e `session.execute()`
# ====================================================================

# Routers
router_categorias = APIRouter()
router_centros = APIRouter()
router_atletas = APIRouter()

# ------------------ Rotas de CATEGORIAS ------------------

@router_categorias.post(
    '/', 
    summary='Criar uma nova Categoria',
    status_code=status.HTTP_201_CREATED,
    response_model=CategoriaOut
)
async def post_categoria(db: AsyncSession = Depends(get_db_async), categoria_in: CategoriaIn = Body(...)):
    # Adicionar o objeto diretamente (AsyncSession suporta .add())
    categoria_model = CategoriaModel(**categoria_in.dict())
    db.add(categoria_model)
    try:
        await db.commit() # Operação assíncrona
    except IntegrityError:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f'Já existe uma categoria com o nome: {categoria_in.nome}'
        )
    await db.refresh(categoria_model) # Operação assíncrona
    return categoria_model

@router_categorias.get(
    '/',
    summary='Consultar todas as Categorias',
    status_code=status.HTTP_200_OK,
    response_model=List[CategoriaOut]
)
async def query_categorias(db: AsyncSession = Depends(get_db_async)) -> List[CategoriaOut]:
    # Usar sa_select e .scalars().all() para consulta assíncrona
    stmt = sa_select(CategoriaModel)
    result = await db.execute(stmt)
    categorias = result.scalars().all()
    return categorias


# ------------------ Rotas de CENTROS DE TREINAMENTO ------------------

@router_centros.post(
    '/', 
    summary='Criar um novo Centro de Treinamento',
    status_code=status.HTTP_201_CREATED,
    response_model=CentroTreinamentoOut
)
async def post_ct(db: AsyncSession = Depends(get_db_async), ct_in: CentroTreinamentoIn = Body(...)):
    ct_model = CentroTreinamentoModel(**ct_in.dict())
    db.add(ct_model)
    try:
        await db.commit()
    except IntegrityError:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f'Já existe um CT com o nome: {ct_in.nome}'
        )
    await db.refresh(ct_model)
    return ct_model

@router_centros.get(
    '/',
    summary='Consultar todos os Centros de Treinamento',
    status_code=status.HTTP_200_OK,
    response_model=List[CentroTreinamentoOut]
)
async def query_ct(db: AsyncSession = Depends(get_db_async)) -> List[CentroTreinamentoOut]:
    stmt = sa_select(CentroTreinamentoModel)
    result = await db.execute(stmt)
    centros = result.scalars().all()
    return centros


# ------------------ Rotas de ATLETAS ------------------

@router_atletas.post(
    '/', 
    summary='Criar um novo Atleta',
    status_code=status.HTTP_201
